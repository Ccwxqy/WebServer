
定时器处理非活动连接
==================
由于非活跃连接占用了连接资源，严重影响服务器的性能，通过实现一个服务器定时器，处理这种非活跃连接，释放连接资源。利用alarm函数周期性地触发SIGALRM信号，
该信号的信号处理函数利用管道通知主循环执行定时器链表上的定时任务
>*统一事件源
>*基于升序链表的定时器
>*处理非活动连接

========================
结构体 client_date  
>* 客户端的地址信息
>* 于客户端通信的套接字文件描述符
>* 指向一个定时器，用于管理于该客户端相关的定时任务

定时器类 util_timer
>* time_t expire ：定时器的到期时间
>* void(* cb_func)(client_data *):定时器到期时调用的回调函数，参数为客户端数据
>* client_data *user_data:指向使用该定时器的客户端数据的指针
>* util_timer *prev, *next:指向链表中前一个和后一个定时器的指针，用于在链表中维护定时器的顺序

管理定时器的有序链表类 sort_timer_lst
>* 添加定时器到链表中
>* 调整链表中定时器的位置 保证链表的顺序
>* 从链表中删除一个定时器
>* 定期检查链表，执行到期的定时器，并从链表中删除

提供与网络相关的实用功能类 Utils
>* 初始化定时器处理机制
>* 将文件描述符设置为非阻塞模式
>* 将文件描述符添加到epoll事件监听中
>* 信号处理函数
>* 添加信号处理函数
>* 处理定时事件
>* 显示错误信息



=================================
addsig(int sig, void(handler)(int), bool restart=true)：用于设置特定信号sig的处理函数。它接受一个信号代码、一个信号处理函数handler作为参数，并且可以指定在信号处理函数执行后是否重新启动被该信号中断的系统调用(通过restart参数)

static void sig_handler(int sig):是一个静态成员函数 用作信号的实际处理函数。 当特定信号被触发时，这个函数被调用

void timer_handler()：用于处理与定时器相关的逻辑。通常包括重新设置定时器以周期性地触发信号，从而使得服务器可以周期性地执行维护任务，如检查超时连接

void cb_func(client_data *user_data)：cb_func是一个回调函数，由util_timer的实例在定时事件发生时调用。

///////////////               逻辑关系                ///////////////////
1 信号和定时器的设置
>* 使用addsig函数注册sig_handler作为处理SIGALRM(或其他信号)的函数
>* 通过timer_handler方法设置和管理SIGALRM的触发，确保服务器按预定的时间间隔处理定时任务

2 信号触发和响应
>* 当SIGALRM触发时，操作系统调用sig_handler
>* sig_handler根据信号类型执行相应的操作，如果是定时信号，它可能会调用timer_handler来处理和重置定时器

3 定时器和回调的执行
>* 在timer_handler中，会调用sort_timer_lst的tick()方法，后者遍历定时器列表，检查并触发到期的定时器
>* 当定时器到期时，util_timer实例的cb_func被调用，传入与定时器关联的client_data，以执行具体的业务逻辑