
http连接处理类
==============
根据状态转移，通过主从状态机封装了http连接类。其中，主状态机在内部调用从状态机，从状态机将处理状态和数据传给主状态机
>*客户端发出http连接请求
>*从状态机读取数据，更新自身状态和接收数据，传给主状态机
>*主状态机根据从状态机状态，更新自身状态，决定响应请求还是继续读取

============
http_conn类中有许多函数，扮演着不同的角色，相互之间的逻辑关系大致如下
>*read once()函数负责从网络套接字读取数据到类内部的读缓冲区m_read_buf中，这个函数直接与网络层交互，确保所有可用数据被读入缓冲区，特别是在ET模式下，需要一次性读完所有数据
数据流：将数据从套接字读入到内杯读缓冲区
>*parse_line()函数用于从读缓冲区解析出完整的行。它检查行结束标志'\r\n'，以确定一行的结束，从而为进一步解析请求行 请求头 请求体做准备
数据流：从读缓冲区中解析数据，但数据仍然保留在读缓冲区中
>*parse_request_line(char *text)函数 主要是解析HTTP请求的起始行，获取请求方法 URL 和HTTP版本，这个函数在接收到完整的请求行后被process_read()调用
调用时机：在process_read()中，当parse_line()确认一个完整的行被读取后，parse_requset_line()将对该行进行解析
>*parse_headers(char *text)函数 解析HTTP请求头，每解析完一行，此函数会被调用一次，直到遇到一个空行，表示请求头结束
调用时机:在process_read中，继parse_request_line后，逐行解析头部，每行解析由parse_line()确认
>*parse_content(char *text)函数 解析HTTP请求的内容体。这在处理如POST请求时特别重要，这些请求可能包含上传的数据等
调用时机：在process_read中，一旦头部被解析完并且Content-Length等头部表面有请求体存在，此函数将处理剩余的数据
>*process_read()函数 控制整个HTTP请求的读取和解析流程。整个函数负责调用read_once()以读取数据，然后根据当前的解析状态(请求行 请求头 请求体)调用parse_request_line,parse_headers和parse_content
调用关系：是这些函数的协调者，确保在正确的时间调用正确的解析函数，并管理整个请求的状态

=============
总的逻辑关系和数据流
>*read_once()负责从网络读取数据到读缓冲区
>*parse_line()用于在读缓冲区中确定行的结束
>*根据解析状态，process_read()调用parse_request_line(),parse_headers()或parse_content()来处理读缓冲区中的数据
>*数据始终存储在读缓冲区中，直到被完全解析。解析函数处理的是缓冲区中的数据，不涉及将数据从读缓冲区移动到其他内存区域



============
m_real_file  m_url  m_url_real 三个变量的关系
>*m_url 是一个类成员变量，用于存储从HTTP请求中解析出来的URL。这通常实是请求行中"GET /index.html HTTP/1.1"里面的'/index.html'部分
作用：它提供了客户端请求的资源的相对路径，通常从服务器的根目录开始计算
>*m_real_file 是一个类成员变量，用于存储将要服务的文件的完整文件系统路径。这个变量将'doc_root'(文档根目录)与'm_url'中指定的相对路径结合，形成完整的文件路径
作用：m_real_file是文件系统中定位和访问实际的文件。服务器使用这个路径来打开和读取文件内容，或进行其他的文件系统操作
>*m_url_real 在代码中为局部变量，用于构建或修改从m_url中得到的路径，尤其是在需要动态内容(如CGI脚本)或特殊页面时
作用：处理特定逻辑，如在URL中添加或修改路径，然后这个修改后的URL路径会被拷贝到m_real_file中，以便实际的文件访问，实现重定向

==================
三者关系
>* 从m_url到m_url_real：在需要特别处理请求的路径时(例如动态内容或根据请求类型更改访问的资源)，m_url会被用作基础来创建或修改m_url_real.
>* 从m_url_real到m_real_file：一旦m_url_real被定义并设置好，它的内容会被拷贝或修改后存储到m_real_file中。m_real_file最终包含了从服务器根目录到最终文件的完整路径，用于实际的文件操作



==================
mmap()函数  一个用于创建内存映射的系统调用，通常用于映射文件或设备(通过文件描述符)到进程的地址空间。它允许应用程序直接从内存中访问文件数据，而无需调用读写操作，提高了文件操作效率

mmap()在Web服务器上，通常用于将静态文件(如HTML页面 图片  视频文件等)映射到服务器的内存中

数据从数据库到客户端的流程
>*查询数据库：Web服务器根据需要执行SQL查询或其他数据库操作来检索数据
>*处理数据：服务器可能需要在发送前处理数据，如格式化或包装成HTML JSON等
>*发送数据：处理后的数据通过网络发送给客户端(如浏览器)


==================
write()函数  指的是从服务器的内存中把数据发送到客户端的过程，通过网络连接(socket)

写入过程

数据来源：数据通常来源于两个主要部分：HTTP响应头和HTTP响应体。响应头可能包含状态行和各种头字段，通常存储在一个内存缓冲区中(如m_write_buf)，响应体可能是来自静态文件的内容，这部分内容可能通过mmap()映射到内存中，如m_file_address中的数据
writev()写入：该函数允许将多个不连续的内存块(由iovec结构数组m_iv指定)一次性写入到一个文件描述符-----这里的文件描述符是socket描述符(m_socket)，连接到客户端。通过这种方式，HTTP响应头和HTTP响应体可以同时被发送，不需要将他们合并到一个单一的连续缓存区中

Socket缓冲区和写缓冲区

Socket缓冲区是操作系统管理的，用于暂存从应用程序发往网络的数据。当调用writev()或其他写入函数时，数据首先被复制到这个缓冲区，然后由操作系统复制将数据发送到网络。当缓冲区满时(即EAGAIN错误)，应用程序需要等待有足够的空间再进行数据写入
写缓冲区(m_write_buf)：写缓冲区是应用程序级别的，用于临时存储要发送的数据，如HTTP响应的头部信息。它是应用程序控制的内存区域，用于组织和准备数据，然后将数据传递给socket缓冲区


================
m_iv是iovec结构的数组，它用于writev()函数，来实现向socket发送多个内存区域的数据。每个iovec结构包含一个指向数据的指针iov_base和数据长度iov_len。m_iv[0]用于响应头部，m_iv[1]用于响应主体。
>*m_iv[0]：指向HTTP响应头部数据的内存区域
>*m_iv[1]：指向HTTP响应主体数据的内存区域，通常是从文件映射得来的数据

m_write_idx：标记写缓冲区(m_write_buf)中已经准备好发送的数据的末尾位置。换句话说，m_write_idx表示了在m_write_buf中待发送数据的长度
